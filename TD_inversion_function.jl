using JLD, HDF5
using Dates, MAT
using Glob
using Random, Distributions

# include("MCsub.jl")
function TD_inversion_function(
    TD_parameters::parameters, 
    dataStruct1::MutabledataStruct, 
    chain::Int64
    )
    # This line is needed to make sure that the chains are different from one another
    Random.seed!(chain * Int(round(mod(Dates.millisecond(now()), 1e3)))) 
    dataStruct = deepcopy(dataStruct1)

    #### initialze parameters needed for the iterations ####
    model_num, used_num = 0, 0
    # model
    # zeta, zetacopy, zetasum = [], [], []
    makeplot = TD_parameters.plot_voronoi

    sig_zeta = TD_parameters.zeta_scale * TD_parameters.sig / 100
    sig_sig = TD_parameters.max_sig * TD_parameters.sig / 100

    num_models_per_chain = Int64((TD_parameters.n_iter - TD_parameters.burn_in) / TD_parameters.keep_each)

    xVec, yVec, zVec = dataStruct.xVec, dataStruct.yVec, dataStruct.zVec

    n = length(dataStruct.dataX)
    xr = (TD_parameters.sig / 100) * (max(xVec...) - min(xVec...))
    yr = (TD_parameters.sig / 100) * (max(yVec...) - min(yVec...))
    zr = (TD_parameters.sig / 100) * (max(zVec...) - min(zVec...))

    rayl = sqrt.((dataStruct.rayX[1:end - 1,:] - dataStruct.rayX[2:end,:]).^2 +
    (dataStruct.rayY[1:end - 1,:] - dataStruct.rayY[2:end,:]).^2 +
    (dataStruct.rayZ[1:end - 1,:] - dataStruct.rayZ[2:end,:]).^2)

    U = dataStruct.U
    rayu = 0.5 .* (U[1:end - 1,:] + U[2:end,:])
    
    dataStruct.rayL = rayl
    dataStruct.rayU = rayu

    #====enforce discontinuity?====#

    ######################
    valid = 0 
    println("*******build starting*******")

    # Check if there're existing files generated by checkpoints
    model_checkpoint_lists = glob("chain" * string(chain) * "*")
    if length(model_checkpoint_lists) == 0
        @time while valid == 0
            (model, dataStruct, valid) = build_starting(TD_parameters, dataStruct)
        end
        iter_ind = 1
        model_hist = []
    else
        # yurong 05/30/22: find the saved checkpoint_model with the largest iteration number
        # could overlap the last model with the newest model when saving them
        load_model = load(sort(model_checkpoint_lists)[end])
        # yurong 09/21/22: remove outdated jld file
        for irm in 1:length(model_checkpoint_lists)-1
            rm(sort(model_checkpoint_lists)[irm])
        end
        model = load_model["model"]
        dataStruct = load_model["dataStruct"]
        valid = 1
        iter_ind = Int(load_model["iter"])
        if load_model["burnin"] == true
            model_hist = load_model["model_hist"]
            used_num = load_model["saved_#"]
            model_num = load_model["model_num"]
        else
            model_hist = []
        end
    end
    ##################################
    α = 0
    for iter in iter_ind:TD_parameters.n_iter
        # By using t* error from t* inversion, we no longer use ACTION5 to perturb "allSig"
        action = Int(rand(1:4))
        model.action = action
        model.accept = 0
    
        if action == 1 # Birth
            if model.nCells < TD_parameters.max_cells
                xNew   = rand(1) .* (max(xVec...) - min(xVec...)) .+ min(xVec...)
                yNew   = rand(1) .* (max(yVec...) - min(yVec...)) .+ min(yVec...)
                zNew   = rand(1) .* (max(zVec...) - min(zVec...)) .+ min(zVec...)
                czeta = Interpolation(TD_parameters, model, xNew, yNew, zNew)[1]
                zetanew = rand(Normal(czeta, sig_zeta), 1)[1]

                modeln = deepcopy(model)
                append!(modeln.xCell, xNew)
                append!(modeln.yCell, yNew)
                append!(modeln.zCell, zNew)
                append!(modeln.zeta, zetanew)
                append!(modeln.layer, 1)
                modeln.nCells += 1

                if TD_parameters.prior == 1 # Uniform
                    if zetanew > 0 && zetanew < TD_parameters.zeta_scale
                        (modeln, dataStructn, valid) = evaluate(modeln, dataStruct, TD_parameters)
                       
                        # α(birth), Byrnes and Bezada, 2020, eq. 16
                        α = ((model.nCells) / (model.nCells + 1)) * ((sig_zeta * sqrt(2 * pi)) / (TD_parameters.zeta_scale)) * 
                        exp(((czeta - zetanew)^2) / (2 * sig_zeta^2) - (modeln.phi - model.phi) / 2)
                        # α = ((model["nCells"][1]) / (model["nCells"][1] + 1)) * ((TD_parameters["zeta_scale"] * sqrt(2 * pi)) / (TD_parameters["sig_zeta"])) * 
                        # exp(((czeta - zetanew)^2) / (2 * TD_parameters["sig_zeta"]^2) - (modeln["phi"][1] - model["phi"][1]) / 2)
                        α = min([1 α]...)

                    else
                        valid = 0
                    end
                elseif TD_parameters.prior == 2 # Normal
                    (modeln, dataStructn, valid) = evaluate(modeln, dataStruct, TD_parameters)
                    α = ((model.nCells) / (model.nCells + 1)) * (sig_zeta / TD_parameters.zeta_scale) * 
                    exp(-(zetanew)^2 / (TD_parameters.zeta_scale^2) + (czeta - zetanew)^2 / (2 * sig_zeta^2) - (modeln.phi - model.phi) / 2)
                    α = min([1 α]...)
                elseif TD_parameters.prior == 3 # Exponential
                    if zetanew > 0
                        (modeln, dataStructn, valid) = evaluate(modeln, dataStruct, TD_parameters)
                        α = ((model.nCells) / (model.nCells + 1)) * (sqrt(2 * pi) * sig_zeta / TD_parameters.zeta_scale) * 
                        exp(-zetanew / TD_parameters.zeta_scale + (czeta - zetanew)^2 / (2 * sig_zeta^2) - (modeln.phi - model.phi) / 2)
                        α = min([1 α]...)  
                    else
                        valid = 0
                    end
                end

                if rand(1)[1] < α && valid == 1
                    model = deepcopy(modeln)
                    dataStruct = deepcopy(dataStructn)
                    model.accept = 1
                end
            end
        elseif action == 2 # Death
            if model.nCells > TD_parameters.min_cells
                kill = Int(rand(1:model.nCells))

                modeln =  deepcopy(model)

                deleteat!(modeln.xCell, kill)
                deleteat!(modeln.yCell, kill)
                deleteat!(modeln.zCell, kill)
                deleteat!(modeln.zeta, kill)
                deleteat!(modeln.layer, kill)
                modeln.nCells -= 1
                # ATTENTION! how to deal with id_n
                # id_n       = model["id"]
                # setindex!(modeln, id_n, "id")
            
                # make sure you haven't removed all the nodes from one layer
                nlayer = 0
                for i in model.layer
                    if i == model.layer[kill]
                        nlayer += 1
                    end
                end
                if nlayer > 1
                    (modeln, dataStructn, valid) = evaluate(modeln, dataStruct, TD_parameters)
                    # F = return_interpolant(modeln, (modeln.layer == model.layer(kill)), TD_parameters.interp_style);

                    # ATTENTION! any(yVec) line304
                    # println([model["xCell"][kill]])
                    zetanew = Interpolation(TD_parameters, modeln, [model.xCell[kill]], [model.yCell[kill]], [model.zCell[kill]])[1]

                    # α(death), Byrnes and Bezada, 2020, eq. 17
                    
                    if TD_parameters.prior == 1 # Uniform
                        α = ((model.nCells) / (model.nCells - 1)) * ((TD_parameters.zeta_scale) / (sig_zeta * sqrt(2 * pi))) * 
                        exp(-((model.zeta[kill] - zetanew)^2) / (2 * sig_zeta^2) - (modeln.phi - model.phi) / 2)
                        # α = ((model["nCells"][1]) / (model["nCells"][1] - 1)) * ((TD_parameters["sig_zeta"]) / (TD_parameters["zeta_scale"] * sqrt(2 * pi))) * 
                        # exp(-((model["zeta"][kill] - zetanew)^2) / (2 * TD_parameters["sig_zeta"]^2) - (modeln["phi"][1] - model["phi"][1]) / 2)
                        # push!(alpha2,α)
                        α = min([1 α]...)           
                    elseif TD_parameters.prior == 2 # Normal
                        # ATTENTION! check whether it exist
                        (modeln, dataStructn, valid) = evaluate(modeln, dataStruct, TD_parameters)
                        α = ((model.nCells) / (model.nCells - 1)) * (TD_parameters.zeta_scale / sig_zeta) * 
                        exp((model.zeta[kill]^2) / (2 * TD_parameters.zeta_scale^2) - (model.zeta[kill] - zetanew)^2 / (2 * sig_zeta^2) - 
                        (modeln.phi - model.phi) / 2)
                        α = min([1 α]...)
                    elseif TD_parameters.prior == 3 # Exponential
                        if zetanew > 0
                            α = ((model.nCells) / (model.nCells - 1)) * (TD_parameters.zeta_scale / (sqrt(2 * pi) * sig_zeta)) * 
                            exp(model.zeta[kill] / TD_parameters.zeta_scale - (model.zeta[kill] - zetanew)^2 / (2 * sig_zeta^2) - 
                            (modeln.phi - model.phi) / 2)
                            α = min([1 α]...)  
                        else
                            valid = 0
                        end
                    end                    
                else
                    valid = 0
                end

                if rand(1)[1] < α && valid == 1
                    model = deepcopy(modeln)
                    dataStruct = deepcopy(dataStructn)
                    model.accept = 1
                end
            end
        
        elseif action == 3 # change ζ in a cell
            change = Int(rand(1:model.nCells))
            
            modeln =  deepcopy(model)
            # Random.seed!(1234)
            zetan = rand(Normal(model.zeta[change], sig_zeta), 1)[1]
            modeln.zeta[change] = zetan
            
            (modeln, dataStructn, valid) = evaluate(modeln, dataStruct, TD_parameters)
            # α(change), Byrnes and Bezada, 2020, eq. 15
            # ATTENTION! it seems that the formula in the paper is the same as 'normal', but where does 'exponential' and 'uniform' comes from?     
            if TD_parameters.prior == 1 # Uniform
                if modeln.zeta[change] > 0 && modeln.zeta[change] < TD_parameters.zeta_scale
                    α = exp(-(modeln.phi - model.phi) / 2)
                    α = min([1 α]...)
                else
                    valid = 0;
                end      
            elseif TD_parameters.prior == 2 # Normal
                α = exp( (model.zeta[change]^2 - modeln.zeta[change]^2) / (2 * TD_parameters.zeta_scale^2) -
                (modeln.phi - model.phi) / 2)
                α = min([1 α]...)
            elseif TD_parameters.prior == 3 # Exponential
                if modeln.zeta[change] > 0
                    α = exp( (model.zeta[change] - modeln.zeta[change]) / TD_parameters.zeta_scale -
                    (modeln.phi - model.phi) / 2)
                    α = min([1 α]...)  
                else
                    α = 0
                end
            end 
            if rand(1)[1] < α && valid == 1
                # println(valid, ' ', action)
                model = deepcopy(modeln)
                dataStruct = deepcopy(dataStructn)
                model.accept = 1
            end        

        elseif action == 4 # move
            if model.nCells > 0
                move = Int(rand(1:model.nCells))

                modeln = deepcopy(model)

                xCell_n = rand(Normal(model.xCell[move], xr), 1)[1]
                yCell_n = rand(Normal(model.yCell[move], yr), 1)[1]
                zCell_n = rand(Normal(model.zCell[move], zr), 1)[1]

                if xCell_n >= min(xVec...) && xCell_n <= max(xVec...) &&
                    yCell_n >= min(yVec...) && yCell_n <= max(yVec...) &&
                    zCell_n >= min(zVec...) && zCell_n <= max(zVec...)

                    modeln.xCell[move] = xCell_n
                    modeln.yCell[move] = yCell_n
                    modeln.zCell[move] = zCell_n

                    (modeln, dataStructn, valid) = evaluate(modeln, dataStruct, TD_parameters)
                    
                    # α(move), Byrnes and Bezada, 2020, eq. 14
                    α = exp(-(modeln.phi - model.phi) / 2)
                    α = min([1 α]...) 
                else
                    valid = 0 
                end

                if rand(1)[1] < α && valid == 1
                    model = deepcopy(modeln)
                    dataStruct = deepcopy(dataStructn)
                    model.accept = 1
                end
            end
        elseif action == 5 # change sigma

            sig_n = rand(Normal(model.allSig, sig_sig), 1)[1] 
            allSig_n = sig_n * ones(size(dataStruct.tS))

            if sig_n > 0 && sig_n < TD_parameters.max_sig

                dataStructn        = deepcopy(dataStruct)
                dataStructn.allSig = allSig_n
                (modeln, dataStructn, valid) = evaluate(model, dataStructn, TD_parameters)

                # α(error), Byrnes and Bezada, 2020, eq. 18
                α = log(model.allSig / sig_n) * n - (modeln.phi - model.phi) / 2
                α = min([log(1) α]...)

                if log(rand(1)[1]) <= α && valid == 1
                    model = deepcopy(modeln)
                    dataStruct = deepcopy(dataStructn)
                    model.allSig = sig_n
                    model.accept = 1
                end
            end

        end
        (m, n) = size(dataStruct.rayZ)
        if iter >= TD_parameters.burn_in
            model_num += 1
            if mod(model_num, TD_parameters.keep_each) == 0
                used_num += 1 
                push!(model_hist, model)

                if mod(100 * used_num / num_models_per_chain, 10) < 1e-9 || used_num == 1
                    CurrentModel = model
                    modelname = "chain" * string(chain) * "_iter" * string(Int(iter)) * "_" * string(100 * iter / TD_parameters.n_iter)* "%.jld"
                    save(modelname,"model",CurrentModel,"dataStruct",dataStruct,"iter",iter,"saved_#",used_num,"model_num",model_num,"model_hist",model_hist,"burnin",true)
                    CurrentModel = nothing
                end
            end
        elseif mod(iter, TD_parameters.print_each) == 0
            CurrentModel = model
            modelname = "chain" * string(chain) * "_iter" * string(Int(iter)) * "_" * string(Int(100 * iter / TD_parameters.n_iter))* "%.jld"
            save(modelname,"model",CurrentModel,"dataStruct",dataStruct,"iter",Int64(iter),"burnin",false)
            CurrentModel = nothing
        end

        if mod(iter, TD_parameters.print_each) == 0
            println("Chain #", chain, " at ", 100 * iter / TD_parameters.n_iter, "% with a phi of ", model.phi)
        end

        

    end
    
    return model_hist
end

