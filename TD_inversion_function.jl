using JLD, HDF5
using Dates, MAT
using Glob
using Random, Distributions
# include("MCsub.jl")
function TD_inversion_function(
    TD_parameters::Dict{String,Any}, 
    dataStruct1::Dict{String,AbstractArray}, 
    chain::Int64
    )

    # %This line is needed to make sure that the chains are different from
    # %one another
    # rng(chain*round(mod(now*1e12,1e3)))%seed down to less than the milisecond
    # ATTENTION!
    dataStruct = deepcopy(dataStruct1)
    Random.seed!(chain * Int(round(mod(Dates.millisecond(now()), 1e3))))
    # global model_hist = Dict()
    model_num = 0
    used_num = 0
    model = Dict()
    zeta = []
    zetacopy = []
    zetasum = []
    makeplot = TD_parameters["plot_voronoi"]

    TD_parameters["sig_zeta"] = TD_parameters["zeta_scale"] * TD_parameters["sig"] / 100
    TD_parameters["sig_sig"] = TD_parameters["max_sig"] * TD_parameters["sig"] / 100

    num_models_per_chain = Int64((TD_parameters["n_iter"] - TD_parameters["burn_in"]) / TD_parameters["keep_each"])

    xVec = dataStruct["xVec"]
    yVec = dataStruct["yVec"]
    zVec = dataStruct["zVec"]

    n = length(dataStruct["dataX"])
    xr = (TD_parameters["sig"] / 100) * (max(xVec...) - min(xVec...))
    yr = (TD_parameters["sig"] / 100) * (max(yVec...) - min(yVec...))
    zr = (TD_parameters["sig"] / 100) * (max(zVec...) - min(zVec...))

    ########ATTENTION! discontinuity rmfiled

    # if ~TD_parameters.enforce_discon && isfield(dataStruct, 'discontinuity')
    
    #     dataStruct = rmfield(dataStruct, 'discontinuity');
        
    # end

    # collect x,y,z matrices for each ray (eg: x[m,n],m is the # of points in a ray, n is the # of rays)
    # collect slowness matrix U[m,n]

    # for k in 1:length(dataStruct["ray"])
    #     x1 = dataStruct["ray"][k].x
    #     y1 = dataStruct["ray"][k].y
    #     # z1 = dataStruct["ray"][k].z
    #     # ATTENTION! why don't we use rayz? : related to rayL, * rayU, rayU is defined in zVec
    #     z1 = dataStruct["zVec"]
    #     U1 = dataStruct["ray"][k].U
    #     if k == 1
    #         x = x1;y = y1;z = z1;U = U1
    #     else
    #         x = [x x1];y = [y y1];z = [z z1];U = [U U1]
    #     end
    # end

    # (n, m) = size(dataStruct["rayX"])

    # rayL: length between neibouring points in kᵗʰ ray; rayU: slowness between neibouring points in kᵗʰ ray
    rayl = sqrt.((dataStruct["rayX"][1:end - 1,:] - dataStruct["rayX"][2:end,:]).^2 +
    (dataStruct["rayY"][1:end - 1,:] - dataStruct["rayY"][2:end,:]).^2 +
    (dataStruct["rayZ"][1:end - 1,:] - dataStruct["rayZ"][2:end,:]).^2)

    # (n,m) = size(rayl)
    # for i in 1:m
    #     single_rayl = rayl[:,i]
        
    #     index = findall(x -> isnan(x), single_rayl)
    #     if isempty(index)
    #         break
    #     else
    #         rayl[index[1]-1,i]=0
    #     end
    #     # println(index)
    #     # rayl[findall(x -> x==0, single_rayl)[1]-1,i] = 0
    # end

    U = dataStruct["U"]
    rayu = 0.5 .* (U[1:end - 1,:] + U[2:end,:])
    
    setindex!(dataStruct, rayl, "rayL")
    setindex!(dataStruct, rayu, "rayU")
    # println(size(dataStruct["rayL"]))

    ###############ATTENTION! enforce_discon related####################


    valid = 0 

    println("*******build starting*******")
    # ATTENTION! Judging from the existence of the jld files to decide whether to read or not
    
    # See if there're existing files generated by checkpoints
    model_checkpoint_lists = glob("chain" * string(chain) * "*")
    if length(model_checkpoint_lists) == 0
        @time while valid == 0
            (model, dataStruct, valid) = build_starting(TD_parameters, dataStruct)
        end
        iter_ind = 1
        model_hist = []
    else
        # yurong 05/30/22: find the saved checkpoint_model with the largest iteration number
        # could overlap the last model with the newest model when saving them
        load_model = load(sort(model_checkpoint_lists)[end])
        model = load_model["model"]
        dataStruct = load_model["dataStruct"]
        valid = 1
        iter_ind = Int(load_model["iter"])
        if load_model["burnin"] == true
            model_hist = load_model["model_hist"]
            used_num = load_model["saved_#"]
            model_num = load_model["model_num"]
        else
            model_hist = []
        end
    end



    # read_model= false
    

    # if read_model == true
    # #if iter_*file exists, flag==True, skip build_starting (remember to save datastruct)
    #     loadmodel = load("iter400.0_40.010%.jld")
    #     model = loadmodel["model"]
    #     iter_ind = 400
    #     #ATTENTION! from "burnin", decide the 'used_num' 'model_hist'
    # else
    #     @time while valid == 0
    #         (model, dataStruct, valid) = build_starting(TD_parameters, dataStruct)
    #         # println("*******build starting*******")
    #     end
    #     iter_ind = 1
    # end


    
    α = 0
    # model_hist = []
    # f1=open("goodsig.txt","a")
    # f2=open("badsig.txt","a")
    # f3=open("allsig.txt","a")
    # CellNum = []
    # alpha1 = []
    # alpha2 = []

    # num_saved_models_per_chain = Int64((TD_parameters["n_iter"] - TD_parameters["burn_in"]) / TD_parameters["keep_each"])
    # model_hist = []
    for iter in iter_ind:TD_parameters["n_iter"]

        
        if TD_parameters["sig_sig"] > 0
            action = Int(rand(1:4))
            ##use Shawn's results, say we have 'allSig' term
            # action = Int(rand(1:5))
        else
            action = Int(rand(1:4))
        end
        # println(iter,' ',action)
        setindex!(model, [action], "action")
        setindex!(model, [0], "accept")
        # @match action begin
        #     1              => println("Integers are awesome!")
        #     2          => println("Strings are the best")
        #     3 => println("Ints for Strings?")
        #     4             => println("A Dict! Looking up a word?")
        #     _                    => println("Something unexpected")
        # end
        if action == 1 # Birth
            if model["nCells"][1] < TD_parameters["max_cells"]
                xNew   = rand(1) .* (max(xVec...) - min(xVec...)) .+ min(xVec...)
                yNew   = rand(1) .* (max(yVec...) - min(yVec...)) .+ min(yVec...)
                zNew   = rand(1) .* (max(zVec...) - min(zVec...)) .+ min(zVec...)

                # ATTENTION! discon layer_n
                # layer_n = [model["layer"];1]
                node_index = 1:model["nCells"][1]

                czeta = Interpolation(TD_parameters, model, xNew, yNew, zNew)[1]
                zetanew = rand(Normal(czeta, TD_parameters["sig_zeta"]), 1)[1]

                modeln = deepcopy(model)
                # id_n       = [ model["id"]; max(model["id"]...)+1]
                # append!(modeln["id"],max(model["id"]...).+1)
                append!(modeln["xCell"], xNew) 
                append!(modeln["yCell"], yNew)
                append!(modeln["zCell"], zNew)
                append!(modeln["zeta"], zetanew)
                # ATTENTION! layer related to discon
                append!(modeln["layer"], 1)
                setindex!(modeln, [modeln["nCells"][1] + 1], "nCells")

                if TD_parameters["prior"] == 1 # Uniform
                    if zetanew > 0 && zetanew < TD_parameters["zeta_scale"]
                        (modeln, dataStructn, valid) = evaluate(modeln, dataStruct, TD_parameters)
                        # α(birth), Byrnes and Bezada, 2020, eq. 16
                        
                        α = ((model["nCells"][1]) / (model["nCells"][1] + 1)) * ((TD_parameters["sig_zeta"] * sqrt(2 * pi)) / (TD_parameters["zeta_scale"])) * 
                        exp(((czeta - zetanew)^2) / (2 * TD_parameters["sig_zeta"]^2) - (modeln["phi"][1] - model["phi"][1]) / 2)
                        # push!(alpha1,α)
                        α = min([1 α]...)
                
                    else

                        valid = 0

                    end
                elseif TD_parameters["prior"] == 2 # Normal
                    (modeln, dataStructn, valid) = evaluate(modeln, dataStruct, TD_parameters)
                    α = ((model["nCells"][1]) / (model["nCells"][1] + 1)) * (TD_parameters["sig_zeta"] / TD_parameters["zeta_scale"]) * 
                    exp(-(zetanew)^2 / (TD_parameters["zeta_scale"]^2) + (czeta - zetanew)^2 / (2 * TD_parameters["sig_zeta"]^2) - (modeln["phi"][1] - model["phi"][1]) / 2)
                    α = min([1 α]...)
                elseif TD_parameters["prior"] == 3 # Exponential
                    if zetanew > 0
                        (modeln, dataStructn, valid) = evaluate(modeln, dataStruct, TD_parameters)
                        α = ((model["nCells"][1]) / (model["nCells"][1] + 1)) * (sqrt(2 * pi) * TD_parameters["sig_zeta"] / TD_parameters["zeta_scale"]) * 
                        exp(-zetanew / TD_parameters["zeta_scale"] + (czeta - zetanew)^2 / (2 * TD_parameters["sig_zeta"]^2) - (modeln["phi"][1] - model["phi"][1]) / 2)
                        α = min([1 α]...)  
                    else
                        valid = 0
                    end
                end

                if rand(1)[1] < α && valid == 1
                # if valid == 1
                    # println(valid, ' ', action)
                    model = deepcopy(modeln)
                    dataStruct = deepcopy(dataStructn)
                    setindex!(model, [1], "accept")
                end
            end

        elseif action == 2 # Death
            if model["nCells"][1] > TD_parameters["min_cells"]
                kill = Int(rand(1:model["nCells"][1]))

                modeln =  deepcopy(model)

                deleteat!(modeln["xCell"], kill)
                deleteat!(modeln["yCell"], kill)
                deleteat!(modeln["zCell"], kill)
                deleteat!(modeln["zeta"], kill)
                deleteat!(modeln["layer"], kill)
                setindex!(modeln, [modeln["nCells"][1] - 1], "nCells")
                # ATTENTION! how to deal with id_n
                # id_n       = model["id"]
                # setindex!(modeln, id_n, "id")
            
                # make sure you haven't removed all the nodes from one layer
                nlayer = 0
                for i in model["layer"]
                    if i == model["layer"][kill]
                        nlayer += 1
                    end
                end
                println(nlayer)
                if nlayer > 1
                    (modeln, dataStructn, valid) = evaluate(modeln, dataStruct, TD_parameters)
                    # F = return_interpolant(modeln, (modeln.layer == model.layer(kill)), TD_parameters.interp_style);

                    # ATTENTION! any(yVec) line304
                    # println([model["xCell"][kill]])
                    zetanew = Interpolation(TD_parameters, modeln, [model["xCell"][kill]], [model["yCell"][kill]], [model["zCell"][kill]])[1]

                    # α(death), Byrnes and Bezada, 2020, eq. 17
                    
                    if TD_parameters["prior"] == 1 # Uniform
                        α = ((model["nCells"][1]) / (model["nCells"][1] - 1)) * ((TD_parameters["zeta_scale"]) / (TD_parameters["sig_zeta"] * sqrt(2 * pi))) * 
                        exp(-((model["zeta"][kill] - zetanew)^2) / (2 * TD_parameters["sig_zeta"]^2) - (modeln["phi"][1] - model["phi"][1]) / 2)
                        # α = ((model["nCells"][1]) / (model["nCells"][1] - 1)) * ((TD_parameters["sig_zeta"]) / (TD_parameters["zeta_scale"] * sqrt(2 * pi))) * 
                        # exp(-((model["zeta"][kill] - zetanew)^2) / (2 * TD_parameters["sig_zeta"]^2) - (modeln["phi"][1] - model["phi"][1]) / 2)
                        # push!(alpha2,α)
                        α = min([1 α]...)           
                    elseif TD_parameters["prior"] == 2 # Normal
                        # ATTENTION! check whether it exist
                        (modeln, dataStructn, valid) = evaluate(modeln, dataStruct, TD_parameters)
                        α = ((model["nCells"][1]) / (model["nCells"][1] - 1)) * (TD_parameters["zeta_scale"] / TD_parameters["sig_zeta"]) * 
                        exp((model["zeta"][kill]^2) / (2 * TD_parameters["zeta_scale"]^2) - (model["zeta"][kill] - zetanew)^2 / (2 * TD_parameters["sig_zeta"]^2) - 
                        (modeln["phi"][1] - model["phi"][1]) / 2)
                        α = min([1 α]...)
                    elseif TD_parameters["prior"] == 3 # Exponential
                        if zetanew > 0
                            α = ((model["nCells"][1]) / (model["nCells"][1] - 1)) * (TD_parameters["zeta_scale"] / (sqrt(2 * pi) * TD_parameters["sig_zeta"])) * 
                            exp(model["zeta"][kill] / TD_parameters["zeta_scale"] - (model["zeta"][kill] - zetanew)^2 / (2 * TD_parameters["sig_zeta"]^2) - 
                            (modeln["phi"][1] - model["phi"][1]) / 2)
                            α = min([1 α]...)  
                        else
                            valid = 0
                        end
                    end                    
                else
                    valid = 0
                end
                # ATTENTION! %make sure you haven't removed all the nodes from one
                #     %layer
                # if TD_parameters.enforce_discon && length(unique(modeln.layer)) == 1
                        
                #     valid = 0;
                    
                # end
                if rand(1)[1] < α && valid == 1
                    # println(valid, ' ', action)
                # if valid == 1
                    model = deepcopy(modeln)
                    dataStruct = deepcopy(dataStructn)
                    setindex!(model, [1], "accept")
                end
            end

        elseif action == 3 # change ζ in a cell
            change = Int(rand(1:model["nCells"][1]))
            
            modeln =  deepcopy(model)
            # Random.seed!(1234)
            zetan = rand(Normal(model["zeta"][change], TD_parameters["sig_zeta"]), 1)[1]
            modeln["zeta"][change] = zetan
            
            (modeln, dataStructn, valid) = evaluate(modeln, dataStruct, TD_parameters)
            # α(change), Byrnes and Bezada, 2020, eq. 15
            # ATTENTION! it seems that the formula in the paper is the same as 'normal', but where does 'exponential' and 'uniform' comes from?     
            if TD_parameters["prior"] == 1 # Uniform
                if modeln["zeta"][change] > 0 && modeln["zeta"][change] < TD_parameters["zeta_scale"] 
                    α = exp(-(modeln["phi"][1] - model["phi"][1]) / 2)
                    α = min([1 α]...)
                else
                    valid = 0;
                end      
            elseif TD_parameters["prior"] == 2 # Normal
                α = exp( (model["zeta"][change]^2 - modeln["zeta"][change]^2) / (2 * TD_parameters["zeta_scale"]^2) -
                (modeln["phi"][1] - model["phi"][1]) / 2)
                α = min([1 α]...)
            elseif TD_parameters["prior"] == 3 # Exponential
                if modeln["zeta"][change] > 0
                    α = exp( (model["zeta"][change] - modeln["zeta"][change]) / TD_parameters["zeta_scale"] -
                    (modeln["phi"][1] - model["phi"][1]) / 2)
                    α = min([1 α]...)  
                else
                    α = 0
                end
            end 
            if rand(1)[1] < α && valid == 1
                # println(valid, ' ', action)
                model = deepcopy(modeln)
                dataStruct = deepcopy(dataStructn)
                setindex!(model, [1], "accept")
            end

        elseif action == 4 # move
            if model["nCells"][1] > 0
                move = Int(rand(1:model["nCells"][1]))

                modeln = deepcopy(model)

                xCell_n = rand(Normal(model["xCell"][move], xr), 1)[1]
                yCell_n = rand(Normal(model["yCell"][move], yr), 1)[1]
                zCell_n = rand(Normal(model["zCell"][move], zr), 1)[1]

                # ATTENTION! line 449; layer_n change? related to discon

                if xCell_n >= min(xVec...) && xCell_n <= max(xVec...) &&
                    yCell_n >= min(yVec...) && yCell_n <= max(yVec...) &&
                    zCell_n >= min(zVec...) && zCell_n <= max(zVec...)

                    modeln["xCell"][move] = xCell_n
                    modeln["yCell"][move] = yCell_n
                    modeln["zCell"][move] = zCell_n
                    # modeln.layer = layer_n;

                    # %now pick which ones should be updated
                    # %vn1                 = voronoi_neighbor(model);
                    # %vn2                 = voronoi_neighbor(modeln);
                    # %modeln.node_change  = full(vn1(move, :) & vn2(move, :));%update everything bordering the node in either position
                    

                    (modeln, dataStructn, valid) = evaluate(modeln, dataStruct, TD_parameters)
                    
                    # α(move), Byrnes and Bezada, 2020, eq. 14
                    α = exp(-(modeln["phi"][1] - model["phi"][1]) / 2)
                    α = min([1 α]...) 
                else
                    valid = 0 
                end

                if rand(1)[1] < α && valid == 1
                    # println(valid, ' ', action)
                    model = deepcopy(modeln)
                    dataStruct = deepcopy(dataStructn)
                    setindex!(model, [1], "accept")
                end
            end

            
        elseif action == 5 # change sigma

            sig_n = rand(Normal(model["allSig"][1], TD_parameters["sig_sig"][1]), 1)[1] 
            allSig_n = sig_n * ones(size(dataStruct["tS"]))

            if sig_n > 0 && sig_n < TD_parameters["max_sig"]
                # writedlm(f1,[sig_n TD_parameters["max_sig"] model["allSig"] TD_parameters["sig_sig"]])
                # writedlm(f3,[sig_n TD_parameters["max_sig"] model["allSig"] TD_parameters["sig_sig"]])
                dataStructn        = deepcopy(dataStruct)
                setindex!(dataStructn, allSig_n, "allSig")
                (modeln, dataStructn, valid) = evaluate(model, dataStructn, TD_parameters)

                # α(error), Byrnes and Bezada, 2020, eq. 18
                # ATTENTION! why change to log form?
                # println(n)
                α = log(model["allSig"][1] / sig_n) * n - (modeln["phi"][1] - model["phi"][1]) / 2
                α = min([log(1) α]...)

                if log(rand(1)[1]) <= α && valid == 1
                    # println(valid, ' ', action)
                    model = deepcopy(modeln)
                    dataStruct = deepcopy(dataStructn)
                    model["allSig"] = [sig_n]
                    setindex!(model, [1], "accept")
                end
            else
                # writedlm(f2,[sig_n TD_parameters["max_sig"] model["allSig"] TD_parameters["sig_sig"]])
                # writedlm(f3,[sig_n TD_parameters["max_sig"] model["allSig"] TD_parameters["sig_sig"]])
            end
        end
        (m, n) = size(dataStruct["rayZ"])

        if iter >= TD_parameters["burn_in"] # && model["phi"][1] < 100.0*n# && model["accept"][1] == 1
        # if iter >= TD_parameters["burn_in"] && mod(iter, TD_parameters["keep_each"]) == 0
            model_num += 1   
            if mod(model_num, TD_parameters["keep_each"]) == 0
            # if 3>1
                used_num += 1 
                # if TD_parameters["xzMap"] == 1
                #     zeta = []
                #     for i in 1:length(dataStruct["zVec"])
                #         tmp = Interpolation(TD_parameters, model, dataStruct["xVec"], TD_parameters["ySlice"], ones(length(dataStruct["xVec"])) .* dataStruct["zVec"][i])
                #         zeta = vcat(zeta, tmp)
                #     end
                #     zetacopy = deepcopy(zeta) 
                # elseif TD_parameters["xyMap"] == 1
                #     zeta = []
                #     for i in 1:length(dataStruct["yVec"])
                #         tmp = Interpolation(TD_parameters, model, dataStruct["xVec"], ones(length(dataStruct["xVec"])) .* dataStruct["yVec"][i], TD_parameters["zSlice"])
                #         zeta = vcat(zeta, tmp)
                #     end
                #     zetacopy = deepcopy(zeta) 
                # end
                # if used_num == 1
                #     zetasum = deepcopy(zetacopy)
                # else
                #     zetasum = zetasum .+ zetacopy
                # end
                push!(model_hist, model)

                if mod(100 * used_num / num_models_per_chain, 10) < 1e-9 || used_num == 1
                    CurrentModel = model
                    # modelname = "chain" * string(chain) * "_iter" * string(iter) * "_" * string(100 * used_num / num_models_per_chain, 10) * "%.jld"
                    modelname = "chain" * string(chain) * "_iter" * string(Int(iter)) * "_" * string(100 * iter / TD_parameters["n_iter"])* "%.jld"
                    save(modelname,"model",CurrentModel,"dataStruct",dataStruct,"iter",iter,"saved_#",used_num,"model_num",model_num,"model_hist",model_hist,"burnin",true)
                    CurrentModel = nothing
                end
                # savename = "./IndividualModels/chain#" * string(chain) * ('_') * string(used_num) * ".jld"
                # save(savename, "model", model, "zeta", zeta)

                # if makeplot == 1 && (mod(used_num, 10) == 0 || used_num == 1)
                #     ENV["GKSwstype"] = "nul"
                #     if TD_parameters["xzMap"] == 1
                #     @time p = contourf(vec(dataStruct["xVec"]), vec(dataStruct["zVec"]), vec(zeta), c=:jet, yflip=true)
                #     @time savefig(p, "./voronoi/chain#" * string(chain) * ('_') * string(used_num) * (".png"))
                #     end
                #     if TD_parameters["xyMap"] == 1
                #         p = contourf(vec(dataStruct["xVec"]), vec(dataStruct["yVec"]), vec(zeta), c=:jet)
                #         savefig(p, "./voronoi/chain#" * string(chain) * ('_') * string(used_num) * (".png"))
                #     end
                # end



                # push!(model_hist, model)
            end
        elseif mod(iter, TD_parameters["print_each"]) == 0
            CurrentModel = model
            modelname = "chain" * string(chain) * "_iter" * string(Int(iter)) * "_" * string(Int(100 * iter / TD_parameters["n_iter"]))* "%.jld"
            save(modelname,"model",CurrentModel,"dataStruct",dataStruct,"iter",Int64(iter),"burnin",false)
            CurrentModel = nothing
        end

        # push!(CellNum, model["nCells"][1])
        if mod(iter, TD_parameters["print_each"]) == 0
            println("Chain #", chain, " at ", 100 * iter / TD_parameters["n_iter"], "% with a phi of ", model["phi"])
        end
        
    end
    # saveinfo = Dict()
    # setindex!(saveinfo, CellNum, "CellNum")
    # setindex!(saveinfo, alpha1, "alpha1")
    # setindex!(saveinfo, alpha2, "alpha2")
    # matwrite("Cellinfo.mat", saveinfo)
    
    # close(f1)
    # close(f2)
    # close(f3)
    

    println("Chain #", chain, " ", TD_parameters["n_iter"], " models created")
    println("Chain #", chain, " ", used_num, " models used")

    # zetareturn = zetasum ./ used_num
    # return (used_num, zetareturn)# model_hist
    # return zetacopy
    # println(chain,varinfo())
    return model_hist
end

